<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è§†é¢‘çº¹ç†æµ‹è¯•</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
    }
    #container {
      display: flex;
      gap: 20px;
    }
    #controls {
      flex: 0 0 300px;
    }
    #canvas-container {
      flex: 1;
      background: #000;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #file-input {
      margin: 10px 0;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      background: #333;
      border-radius: 4px;
      font-size: 12px;
    }
    .status.success {
      background: #2d5016;
    }
    .status.error {
      background: #5d1616;
    }
    video {
      display: none;
    }
  </style>
</head>
<body>
  <h1>ğŸ¬ è§†é¢‘çº¹ç†æµ‹è¯• - Three.js</h1>
  
  <div id="container">
    <div id="controls">
      <h3>æ§åˆ¶é¢æ¿</h3>
      
      <div>
        <input type="file" id="file-input" accept="video/*">
      </div>
      
      <div>
        <button id="play-btn" disabled>â–¶ æ’­æ”¾</button>
        <button id="pause-btn" disabled>â¸ æš‚åœ</button>
      </div>
      
      <div style="margin: 10px 0;">
        <label style="display: block; margin-bottom: 5px;">3Dæ•ˆæœï¼š</label>
        <select id="effect-select" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px;">
          <option value="rotate">ğŸ”„ æ—‹è½¬åŠ¨ç”»</option>
          <option value="float">ğŸˆ æµ®åŠ¨æ•ˆæœ</option>
          <option value="spin">ğŸŒ€ å¿«é€Ÿæ—‹è½¬</option>
          <option value="wave">ğŸŒŠ æ³¢æµªæ•ˆæœ</option>
          <option value="cube">ğŸ² ç«‹æ–¹ä½“ç¿»è½¬</option>
          <option value="particles">âœ¨ ç²’å­çˆ†ç‚¸</option>
          <option value="tunnel">ğŸŒ€ éš§é“ç©¿æ¢­</option>
          <option value="mirror">ğŸª é•œåƒåˆ†è£‚</option>
          <option value="spiral">ğŸŒªï¸ èºæ—‹ä¸Šå‡</option>
          <option value="bounce">ğŸ€ å¼¹è·³æ•ˆæœ</option>
          <option value="glitch">âš¡ æ•…éšœé£</option>
          <option value="matrix">ğŸ’š çŸ©é˜µæ•ˆæœ</option>
          <option value="ripple">ğŸ’§ æ°´æ³¢çº¹</option>
          <option value="kaleidoscope">ğŸ”® ä¸‡èŠ±ç­’</option>
          <option value="videocube">ğŸ“¦ è§†é¢‘ç«‹æ–¹ä½“</option>
          <option value="none">â¹ é™æ­¢</option>
        </select>
      </div>
      
      <div style="margin: 10px 0;">
        <label style="display: block; margin-bottom: 5px;">æ•ˆæœå¼ºåº¦ï¼š</label>
        <input type="range" id="intensity-slider" min="0" max="100" value="50" style="width: 100%;">
        <span id="intensity-value" style="font-size: 12px;">50%</span>
      </div>
      
      <div id="status" class="status">
        ç­‰å¾…å¯¼å…¥è§†é¢‘...
      </div>
      
      <div id="fps" class="status" style="background: #1a3a1a;">
        <strong>æ€§èƒ½ï¼š</strong><br>
        FPS: <span id="fps-value">60</span>
      </div>
      
      <div id="info" class="status">
        <strong>è¯´æ˜ï¼š</strong><br>
        1. é€‰æ‹©ä¸€ä¸ªè§†é¢‘æ–‡ä»¶<br>
        2. è§†é¢‘ä¼šè‡ªåŠ¨æ˜¾ç¤ºåœ¨å³ä¾§3Dåœºæ™¯ä¸­<br>
        3. é€‰æ‹©ä¸åŒçš„3Dæ•ˆæœ<br>
        4. è°ƒæ•´æ•ˆæœå¼ºåº¦æ»‘å—<br>
        5. äº«å—ç‚«é…·çš„3Dè§†é¢‘æ•ˆæœï¼
      </div>
      
      <div id="effect-info" class="status" style="background: #1a1a3a; min-height: 60px;">
        <strong>å½“å‰æ•ˆæœï¼š</strong><br>
        <span id="effect-description">æ—‹è½¬åŠ¨ç”» - è§†é¢‘åœ¨3Dç©ºé—´ä¸­ç¼“æ…¢æ—‹è½¬</span>
      </div>
      
      <div id="cube-info" class="status" style="background: #3a1a1a; display: none;">
        <strong>ç«‹æ–¹ä½“çŠ¶æ€ï¼š</strong><br>
        å½“å‰é¢: <span id="cube-face">å‰é¢</span><br>
        <span id="cube-timer">ä¸‹æ¬¡åˆ‡æ¢: 5ç§’</span>
      </div>
    </div>
    
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <video id="video" muted loop playsinline></video>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

    // è·å–å…ƒç´ 
    const canvas = document.getElementById('canvas');
    const video = document.getElementById('video');
    const fileInput = document.getElementById('file-input');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const statusDiv = document.getElementById('status');
    const effectSelect = document.getElementById('effect-select');
    const intensitySlider = document.getElementById('intensity-slider');
    const intensityValue = document.getElementById('intensity-value');
    const fpsValue = document.getElementById('fps-value');
    const effectDescription = document.getElementById('effect-description');
    const cubeInfo = document.getElementById('cube-info');
    const cubeFace = document.getElementById('cube-face');
    const cubeTimer = document.getElementById('cube-timer');
    
    let effectIntensity = 0.5;
    
    intensitySlider.addEventListener('input', (e) => {
      effectIntensity = e.target.value / 100;
      intensityValue.textContent = e.target.value + '%';
    });
    
    // æ•ˆæœæè¿°
    const effectDescriptions = {
      'rotate': 'æ—‹è½¬åŠ¨ç”» - è§†é¢‘åœ¨3Dç©ºé—´ä¸­ç¼“æ…¢æ—‹è½¬',
      'float': 'æµ®åŠ¨æ•ˆæœ - è§†é¢‘åƒæ°”çƒä¸€æ ·åœ¨ç©ºä¸­é£˜æµ®',
      'spin': 'å¿«é€Ÿæ—‹è½¬ - è§†é¢‘é«˜é€Ÿæ—‹è½¬å±•ç¤º',
      'wave': 'æ³¢æµªæ•ˆæœ - è§†é¢‘åƒæ³¢æµªä¸€æ ·èµ·ä¼',
      'cube': 'ç«‹æ–¹ä½“ç¿»è½¬ - è§†é¢‘åƒç«‹æ–¹ä½“ä¸€æ ·ç¿»è½¬',
      'particles': 'ç²’å­çˆ†ç‚¸ - è§†é¢‘å‘¨å›´ç¯ç»•ç‚«é…·ç²’å­',
      'tunnel': 'éš§é“ç©¿æ¢­ - è§†é¢‘åœ¨éš§é“ä¸­ç©¿æ¢­',
      'mirror': 'é•œåƒåˆ†è£‚ - è§†é¢‘åˆ†è£‚æˆå¤šä¸ªé•œåƒ',
      'spiral': 'èºæ—‹ä¸Šå‡ - è§†é¢‘æ²¿èºæ—‹è·¯å¾„ä¸Šå‡',
      'bounce': 'å¼¹è·³æ•ˆæœ - è§†é¢‘åƒçƒä¸€æ ·å¼¹è·³',
      'glitch': 'æ•…éšœé£ - èµ›åšæœ‹å…‹é£æ ¼çš„æ•…éšœæ•ˆæœ',
      'matrix': 'çŸ©é˜µæ•ˆæœ - é»‘å®¢å¸å›½é£æ ¼çš„ä¸‹è½æ•ˆæœ',
      'ripple': 'æ°´æ³¢çº¹ - è§†é¢‘äº§ç”Ÿæ°´æ³¢çº¹æ‰©æ•£æ•ˆæœ',
      'kaleidoscope': 'ä¸‡èŠ±ç­’ - è§†é¢‘å½¢æˆä¸‡èŠ±ç­’å›¾æ¡ˆ',
      'videocube': 'è§†é¢‘ç«‹æ–¹ä½“ - 3Dç«‹æ–¹ä½“æ¯5ç§’æ—‹è½¬åˆ‡æ¢é¢ï¼Œ6ä¸ªé¢æ’­æ”¾è§†é¢‘',
      'none': 'é™æ­¢ - è§†é¢‘ä¿æŒé™æ­¢çŠ¶æ€'
    };

    // Three.js åœºæ™¯è®¾ç½®
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(50, 9/16, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(1080, 1920);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // è§†é¢‘çº¹ç†å’Œå¹³é¢
    let videoTexture = null;
    let videoPlane = null;
    let particleSystem = null;
    let mirrorPlanes = [];
    let videoCube = null;
    let cubeRotationState = 0; // 0-5 å¯¹åº”6ä¸ªé¢

    // æ›´æ–°çŠ¶æ€
    function updateStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    // æ–‡ä»¶é€‰æ‹©å¤„ç†
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      updateStatus('æ­£åœ¨åŠ è½½è§†é¢‘...', 'info');

      try {
        // åˆ›å»ºå¯¹è±¡URL
        const url = URL.createObjectURL(file);
        video.src = url;

        // ç­‰å¾…å…ƒæ•°æ®åŠ è½½
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = resolve;
          video.onerror = reject;
        });

        updateStatus(`è§†é¢‘åŠ è½½æˆåŠŸï¼åˆ†è¾¨ç‡: ${video.videoWidth}x${video.videoHeight}`, 'success');

        // åˆ›å»ºè§†é¢‘çº¹ç†
        if (videoTexture) {
          videoTexture.dispose();
        }
        videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        // åˆ›å»ºæˆ–æ›´æ–°å¹³é¢
        const aspectRatio = video.videoWidth / video.videoHeight;
        const width = 2;
        const height = width / aspectRatio;

        if (videoPlane) {
          scene.remove(videoPlane);
          videoPlane.geometry.dispose();
          videoPlane.material.dispose();
        }

        const geometry = new THREE.PlaneGeometry(width, height);
        const material = new THREE.MeshBasicMaterial({
          map: videoTexture,
          side: THREE.DoubleSide,
        });

        videoPlane = new THREE.Mesh(geometry, material);
        scene.add(videoPlane);

        // å¯ç”¨æŒ‰é’®
        playBtn.disabled = false;
        pauseBtn.disabled = false;

        // è‡ªåŠ¨æ’­æ”¾
        await video.play();
        updateStatus('è§†é¢‘æ­£åœ¨æ’­æ”¾...', 'success');

      } catch (error) {
        updateStatus(`é”™è¯¯: ${error.message}`, 'error');
        console.error(error);
      }
    });

    // æ’­æ”¾æŒ‰é’®
    playBtn.addEventListener('click', async () => {
      try {
        await video.play();
        updateStatus('è§†é¢‘æ­£åœ¨æ’­æ”¾...', 'success');
      } catch (error) {
        updateStatus(`æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
      }
    });

    // æš‚åœæŒ‰é’®
    pauseBtn.addEventListener('click', () => {
      video.pause();
      updateStatus('è§†é¢‘å·²æš‚åœ', 'info');
    });

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    function createParticleSystem() {
      const particleCount = 1000;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 10;
        positions[i + 1] = (Math.random() - 0.5) * 10;
        positions[i + 2] = (Math.random() - 0.5) * 10;
        
        colors[i] = Math.random();
        colors[i + 1] = Math.random();
        colors[i + 2] = Math.random();
      }
      
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });
      
      return new THREE.Points(particles, particleMaterial);
    }
    
    // åˆ›å»ºé•œåƒå¹³é¢
    function createMirrorPlanes() {
      const planes = [];
      if (!videoTexture) return planes;
      
      for (let i = 0; i < 4; i++) {
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({
          map: videoTexture,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.7
        });
        const plane = new THREE.Mesh(geometry, material);
        planes.push(plane);
        scene.add(plane);
      }
      
      return planes;
    }
    
    // åˆ›å»ºè§†é¢‘ç«‹æ–¹ä½“
    function createVideoCube() {
      if (!videoTexture) return null;
      
      // åˆ›å»ºç«‹æ–¹ä½“å‡ ä½•ä½“
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      
      // ä¸ºæ¯ä¸ªé¢åˆ›å»ºæè´¨ï¼ˆ6ä¸ªé¢éƒ½ä½¿ç”¨åŒä¸€ä¸ªè§†é¢‘çº¹ç†ï¼‰
      const materials = [];
      for (let i = 0; i < 6; i++) {
        materials.push(new THREE.MeshBasicMaterial({
          map: videoTexture,
          side: THREE.FrontSide
        }));
      }
      
      // åˆ›å»ºç«‹æ–¹ä½“ç½‘æ ¼
      const cube = new THREE.Mesh(geometry, materials);
      
      // æ·»åŠ è¾¹æ¡†çº¿ä»¥å¢å¼ºç«‹ä½“æ„Ÿ
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00ffff, 
        linewidth: 2 
      });
      const wireframe = new THREE.LineSegments(edges, lineMaterial);
      cube.add(wireframe);
      
      return cube;
    }

    // å½“å‰æ•ˆæœ
    let currentEffect = 'rotate';
    let lastEffect = 'rotate';
    
    effectSelect.addEventListener('change', (e) => {
      lastEffect = currentEffect;
      currentEffect = e.target.value;
      
      // æ›´æ–°æ•ˆæœæè¿°
      effectDescription.textContent = effectDescriptions[currentEffect] || 'æœªçŸ¥æ•ˆæœ';
      
      // æ˜¾ç¤º/éšè—ç«‹æ–¹ä½“ä¿¡æ¯
      cubeInfo.style.display = currentEffect === 'videocube' ? 'block' : 'none';
      
      // æ¸…ç†ç‰¹æ•ˆ
      if (particleSystem) {
        scene.remove(particleSystem);
        particleSystem = null;
      }
      
      mirrorPlanes.forEach(plane => {
        scene.remove(plane);
        plane.geometry.dispose();
        plane.material.dispose();
      });
      mirrorPlanes = [];
      
      if (videoCube) {
        scene.remove(videoCube);
        videoCube.geometry.dispose();
        videoCube.material.forEach(mat => mat.dispose());
        videoCube = null;
        cubeRotationState = 0;
      }
      
      // é‡ç½®è§†é¢‘å¹³é¢
      if (videoPlane) {
        videoPlane.rotation.set(0, 0, 0);
        videoPlane.position.set(0, 0, 0);
        videoPlane.scale.set(1, 1, 1);
        videoPlane.visible = true;
      }
      
      // åˆå§‹åŒ–ç‰¹å®šæ•ˆæœ
      if (currentEffect === 'particles') {
        particleSystem = createParticleSystem();
        scene.add(particleSystem);
      } else if (currentEffect === 'mirror' || currentEffect === 'kaleidoscope') {
        mirrorPlanes = createMirrorPlanes();
      } else if (currentEffect === 'videocube') {
        videoCube = createVideoCube();
        if (videoCube) {
          scene.add(videoCube);
          if (videoPlane) videoPlane.visible = false;
        }
      }
    });

    // FPSè®¡æ•°å™¨
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let fps = 60;
    
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      const elapsed = currentTime - lastFrameTime;
      
      if (elapsed >= 1000) {
        fps = Math.round((frameCount * 1000) / elapsed);
        fpsValue.textContent = fps;
        fpsValue.style.color = fps >= 50 ? '#4CAF50' : fps >= 30 ? '#FFA500' : '#FF5252';
        frameCount = 0;
        lastFrameTime = currentTime;
      }
    }

    // æ¸²æŸ“å¾ªç¯
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      updateFPS();

      // æ›´æ–°è§†é¢‘çº¹ç†
      if (videoTexture) {
        videoTexture.needsUpdate = true;
      }

      // æ·»åŠ 3DåŠ¨ç”»æ•ˆæœ
      if (videoPlane && currentEffect !== 'none') {
        switch(currentEffect) {
          case 'rotate':
            // ç¼“æ…¢æ—‹è½¬
            videoPlane.rotation.y = Math.sin(time * 0.5) * 0.3;
            videoPlane.rotation.x = Math.sin(time * 0.3) * 0.1;
            videoPlane.position.y = Math.sin(time) * 0.2;
            break;
            
          case 'float':
            // æµ®åŠ¨æ•ˆæœ
            videoPlane.position.y = Math.sin(time) * 0.5;
            videoPlane.position.x = Math.cos(time * 0.7) * 0.3;
            videoPlane.rotation.z = Math.sin(time * 0.5) * 0.1;
            break;
            
          case 'spin':
            // å¿«é€Ÿæ—‹è½¬
            videoPlane.rotation.y = time * 0.5;
            videoPlane.rotation.x = Math.sin(time) * 0.2;
            break;
            
          case 'wave':
            // æ³¢æµªæ•ˆæœ
            videoPlane.rotation.x = Math.sin(time * 2) * 0.3;
            videoPlane.rotation.z = Math.cos(time * 1.5) * 0.2;
            const scale = 1 + Math.sin(time * 3) * 0.1;
            videoPlane.scale.set(scale, scale, 1);
            break;
            
          case 'cube':
            // ç«‹æ–¹ä½“ç¿»è½¬
            videoPlane.rotation.y = Math.floor(time / 2) * Math.PI / 2;
            videoPlane.rotation.x = Math.sin(time * 2) * 0.2;
            break;
            
          case 'particles':
            // ç²’å­çˆ†ç‚¸æ•ˆæœ
            videoPlane.rotation.y = time * 0.3;
            videoPlane.scale.set(
              1 + Math.sin(time * 2) * 0.2,
              1 + Math.cos(time * 2) * 0.2,
              1
            );
            
            if (particleSystem) {
              particleSystem.rotation.y = time * 0.5;
              particleSystem.rotation.x = time * 0.3;
              const positions = particleSystem.geometry.attributes.position.array;
              for (let i = 0; i < positions.length; i += 3) {
                const angle = time + i * 0.01;
                const radius = 3 + Math.sin(time + i * 0.1) * 2;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = Math.sin(angle * 2) * radius;
                positions[i + 2] = Math.sin(angle) * radius;
              }
              particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            break;
            
          case 'tunnel':
            // éš§é“ç©¿æ¢­æ•ˆæœ
            videoPlane.position.z = Math.sin(time) * 2;
            videoPlane.rotation.z = time * 0.5;
            const tunnelScale = 1 + Math.abs(Math.sin(time)) * 0.5;
            videoPlane.scale.set(tunnelScale, tunnelScale, 1);
            break;
            
          case 'mirror':
            // é•œåƒåˆ†è£‚æ•ˆæœ
            videoPlane.visible = false;
            mirrorPlanes.forEach((plane, index) => {
              const angle = (index / mirrorPlanes.length) * Math.PI * 2 + time * 0.5;
              const radius = 1.5 + Math.sin(time * 2) * 0.5;
              plane.position.x = Math.cos(angle) * radius;
              plane.position.y = Math.sin(angle) * radius;
              plane.rotation.z = angle + time;
              plane.scale.set(0.8, 0.8, 1);
            });
            break;
            
          case 'spiral':
            // èºæ—‹ä¸Šå‡æ•ˆæœ
            const spiralAngle = time * 2;
            const spiralRadius = 0.5 + Math.sin(time) * 0.3;
            videoPlane.position.x = Math.cos(spiralAngle) * spiralRadius;
            videoPlane.position.y = (time % 4) - 2;
            videoPlane.position.z = Math.sin(spiralAngle) * spiralRadius;
            videoPlane.rotation.y = spiralAngle;
            break;
            
          case 'bounce':
            // å¼¹è·³æ•ˆæœ
            const bounceHeight = Math.abs(Math.sin(time * 3)) * 2;
            videoPlane.position.y = bounceHeight - 1;
            videoPlane.rotation.x = Math.sin(time * 6) * 0.2;
            const bounceScale = 1 - bounceHeight * 0.1;
            videoPlane.scale.set(bounceScale, bounceScale, 1);
            break;
            
          case 'glitch':
            // æ•…éšœé£æ•ˆæœ
            if (Math.random() > 0.95) {
              videoPlane.position.x = (Math.random() - 0.5) * 0.2;
              videoPlane.position.y = (Math.random() - 0.5) * 0.2;
            } else {
              videoPlane.position.x *= 0.9;
              videoPlane.position.y *= 0.9;
            }
            videoPlane.rotation.z = Math.sin(time * 10) * 0.05;
            videoPlane.scale.set(
              1 + Math.random() * 0.05,
              1 + Math.random() * 0.05,
              1
            );
            break;
            
          case 'matrix':
            // çŸ©é˜µæ•ˆæœ
            videoPlane.position.y = ((time * 2) % 6) - 3;
            videoPlane.rotation.x = Math.PI / 4;
            videoPlane.scale.set(1.5, 1.5, 1);
            scene.background = new THREE.Color(0x001100);
            break;
            
          case 'ripple':
            // æ°´æ³¢çº¹æ•ˆæœ
            const rippleFreq = 5 * effectIntensity;
            const rippleAmp = 0.3 * effectIntensity;
            videoPlane.position.z = Math.sin(time * rippleFreq) * rippleAmp;
            videoPlane.rotation.x = Math.sin(time * rippleFreq + 1) * rippleAmp;
            videoPlane.rotation.y = Math.cos(time * rippleFreq + 2) * rippleAmp;
            
            // åˆ›å»ºæ³¢çº¹ç¼©æ”¾æ•ˆæœ
            const rippleScale = 1 + Math.sin(time * rippleFreq) * 0.2 * effectIntensity;
            videoPlane.scale.set(rippleScale, rippleScale, 1);
            break;
            
          case 'kaleidoscope':
            // ä¸‡èŠ±ç­’æ•ˆæœ - åˆ›å»ºå¤šä¸ªæ—‹è½¬çš„å‰¯æœ¬
            videoPlane.visible = false;
            
            // å¦‚æœè¿˜æ²¡æœ‰åˆ›å»ºä¸‡èŠ±ç­’å¹³é¢ï¼Œåˆ›å»ºå®ƒä»¬
            if (mirrorPlanes.length === 0) {
              for (let i = 0; i < 6; i++) {
                const geometry = new THREE.PlaneGeometry(1.5, 1.5);
                const material = new THREE.MeshBasicMaterial({
                  map: videoTexture,
                  side: THREE.DoubleSide,
                  transparent: true,
                  opacity: 0.8
                });
                const plane = new THREE.Mesh(geometry, material);
                mirrorPlanes.push(plane);
                scene.add(plane);
              }
            }
            
            mirrorPlanes.forEach((plane, index) => {
              const angle = (index / mirrorPlanes.length) * Math.PI * 2 + time * effectIntensity;
              const radius = 0.8;
              plane.position.x = Math.cos(angle) * radius;
              plane.position.y = Math.sin(angle) * radius;
              plane.position.z = Math.sin(time + index) * 0.5;
              plane.rotation.z = -angle + time * 2 * effectIntensity;
              plane.scale.set(1, 1, 1);
            });
            break;
            
          case 'videocube':
            // è§†é¢‘ç«‹æ–¹ä½“æ•ˆæœ - æ¯5ç§’æ—‹è½¬åˆ‡æ¢é¢
            if (videoCube) {
              // è®¡ç®—å½“å‰åº”è¯¥æ˜¾ç¤ºå“ªä¸ªé¢ï¼ˆæ¯5ç§’åˆ‡æ¢ä¸€æ¬¡ï¼‰
              const cycleTime = 5; // 5ç§’ä¸€ä¸ªå‘¨æœŸ
              const currentCycle = Math.floor(time / cycleTime);
              const targetFace = currentCycle % 6; // 0-5 å¯¹åº”6ä¸ªé¢
              
              // æ›´æ–°UIæ˜¾ç¤º
              const faceNames = ['å‰é¢ (Front)', 'å³é¢ (Right)', 'åé¢ (Back)', 'å·¦é¢ (Left)', 'ä¸Šé¢ (Top)', 'ä¸‹é¢ (Bottom)'];
              cubeFace.textContent = faceNames[targetFace];
              const timeLeft = Math.ceil(cycleTime - (time % cycleTime));
              cubeTimer.textContent = `ä¸‹æ¬¡åˆ‡æ¢: ${timeLeft}ç§’`;
              
              // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡æ—‹è½¬è§’åº¦
              const transitionProgress = (time % cycleTime) / cycleTime;
              const easeProgress = transitionProgress < 0.2 ? 
                Math.pow(transitionProgress / 0.2, 2) : 1; // å‰20%æ—¶é—´ç”¨äºæ—‹è½¬
              
              // æ ¹æ®ç›®æ ‡é¢è®¾ç½®æ—‹è½¬
              let targetRotationX = 0;
              let targetRotationY = 0;
              
              switch(targetFace) {
                case 0: // å‰é¢
                  targetRotationX = 0;
                  targetRotationY = 0;
                  break;
                case 1: // å³é¢
                  targetRotationX = 0;
                  targetRotationY = Math.PI / 2;
                  break;
                case 2: // åé¢
                  targetRotationX = 0;
                  targetRotationY = Math.PI;
                  break;
                case 3: // å·¦é¢
                  targetRotationX = 0;
                  targetRotationY = -Math.PI / 2;
                  break;
                case 4: // ä¸Šé¢
                  targetRotationX = -Math.PI / 2;
                  targetRotationY = 0;
                  break;
                case 5: // ä¸‹é¢
                  targetRotationX = Math.PI / 2;
                  targetRotationY = 0;
                  break;
              }
              
              // å¦‚æœæ˜¯æ–°çš„é¢ï¼Œå¼€å§‹æ—‹è½¬åŠ¨ç”»
              if (targetFace !== cubeRotationState) {
                cubeRotationState = targetFace;
              }
              
              // å¹³æ»‘æ’å€¼åˆ°ç›®æ ‡æ—‹è½¬
              const prevFace = (targetFace - 1 + 6) % 6;
              let prevRotationX = 0;
              let prevRotationY = 0;
              
              switch(prevFace) {
                case 0:
                  prevRotationX = 0;
                  prevRotationY = 0;
                  break;
                case 1:
                  prevRotationX = 0;
                  prevRotationY = Math.PI / 2;
                  break;
                case 2:
                  prevRotationX = 0;
                  prevRotationY = Math.PI;
                  break;
                case 3:
                  prevRotationX = 0;
                  prevRotationY = -Math.PI / 2;
                  break;
                case 4:
                  prevRotationX = -Math.PI / 2;
                  prevRotationY = 0;
                  break;
                case 5:
                  prevRotationX = Math.PI / 2;
                  prevRotationY = 0;
                  break;
              }
              
              // æ’å€¼æ—‹è½¬
              videoCube.rotation.x = prevRotationX + (targetRotationX - prevRotationX) * easeProgress;
              videoCube.rotation.y = prevRotationY + (targetRotationY - prevRotationY) * easeProgress;
              
              // æ·»åŠ è½»å¾®çš„æµ®åŠ¨æ•ˆæœ
              videoCube.position.y = Math.sin(time * 0.5) * 0.1;
              
              // æ·»åŠ è½»å¾®çš„è‡ªè½¬
              videoCube.rotation.z = Math.sin(time * 0.3) * 0.05;
              
              // éšè—åŸå§‹å¹³é¢
              if (videoPlane) videoPlane.visible = false;
            }
            break;
        }
      }
      
      // æ¢å¤èƒŒæ™¯è‰²
      if (currentEffect !== 'matrix') {
        scene.background = new THREE.Color(0x000000);
      }

      renderer.render(scene, camera);
    }

    animate();

    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener('resize', () => {
      const container = document.getElementById('canvas-container');
      const width = container.clientWidth;
      const height = width * (1920 / 1080);
      
      camera.aspect = 9 / 16;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });

    // åˆå§‹è°ƒæ•´å¤§å°
    window.dispatchEvent(new Event('resize'));
  </script>
</body>
</html>
